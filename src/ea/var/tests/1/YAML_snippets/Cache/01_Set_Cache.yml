properties:
  descriptions:
    author: admin
    name: TESTCASE
    requirement: REQ_01
    summary: Just a basic sample.
  parameters:
  - description: ''
    name: DATAS
    scope: local
    type: text
    value: |-
      # Save misc data
      [!TO:CACHE:EXAMPLE:];hello world

      # Save server information in the cache
      [!TO:CACHE:SERVER_DESCRIPTION:];[!FROM:INPUT:TEST_PURPOSE:]
  - description: ''
    name: STEP_DESCRIPTION
    scope: local
    type: text
    value: Set values in the cache of your test
  - description: ''
    name: STEP_EXPECTED
    scope: local
    type: text
    value: All values saved
  - description: ''
    name: TEST_PURPOSE
    scope: local
    type: text
    value: Set data in cache
testunit: |2-

  def description(self):
      # testcase description
      self.setPurpose(purpose=input('TEST_PURPOSE'))
      self.setRequirement(requirement=description('requirement'))

      # steps description
      self.step1 = self.addStep(expected=input('STEP_EXPECTED'),
                                description=input('STEP_DESCRIPTION'),
                                summary=input('STEP_DESCRIPTION'),
                                enabled=True)

      i = 0
      block = 3
      for log_msg in input('DATAS').splitlines():
          if not (i % block):
              Trace(self).info(txt="%s" % log_msg[1:].lstrip(), bold=True, italic=False, multiline=False, raw=False)

          if (i % block) == 1:
              if ";" not in log_msg: self.abort("bad data format provided, expected: <.to.>;<.from.>" )

              # separates to with from
              _to, _from = log_msg.split(";", 1)

              # extract the to
              caches = re.findall("\[!TO:CACHE:\w+\:\]", _to)
              if len(caches) != 1: self.abort("bad data format provided, expected: [!TO:CACHE:<.key.>:]" )
              cacheKey = caches[0].split(":")[2:-1][0]

              # extract the from
              inputs = re.findall("\[!FROM:INPUT:\w+\:\]|\[!FROM:OUTPUT:\w+\:\]", _from)
              if len(inputs) > 1: self.abort("bad data format provided, expected: [!FROM:INPUT:<.name.>:] or [!FROM:OUTPUT:<.name.>:]" )

              if len(inputs):
                  name = inputs[0].split(":")[2:-1][0]
                  if "FROM:INPUT" in _from:
                      before = _from.split("[!FROM:INPUT")[0]
                      after = _from.split(":]")[1]
                      v = "%s%s%s" % (before, input(name=name), after)
                      Cache().set(name=cacheKey, data=v, flag=False)
                      Trace(self).warning(txt=v, bold=False, italic=False, multiline=False, raw=False)
                  else:
                      Cache().set(name=cacheKey, data=output(name=name), flag=False)
                      Trace(self).warning(txt=output(name=name), bold=False, italic=False, multiline=False, raw=False)
              else:
                  Cache().set(name=cacheKey, data=_from, flag=False)
                  Trace(self).warning(txt=_from, bold=False, italic=False, multiline=False, raw=False)

          i += 1

  def prepare(self):
      pass
      
  def definition(self):
      # starting initial step
      if self.step1.isEnabled():
          self.step1.start()
          self.step1.setPassed(actual="success")
          
  def cleanup(self, aborted):
      if aborted: self.step1.setFailed(actual="%s" % aborted)
