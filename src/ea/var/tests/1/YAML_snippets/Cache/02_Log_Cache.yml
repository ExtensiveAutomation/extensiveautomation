properties:
  descriptions:
    author: admin
    name: TESTCASE
    requirement: REQ_01
    summary: Just a basic sample.
  parameters:
  - description: ''
    name: MESSAGES
    scope: local
    type: text
    value: "# display cache \n[!FROM:CACHE:EXAMPLE:]\n\n# log timeout input\n[!FROM:INPUT:MESSAGES:]"
  - description: ''
    name: STEP_DESCRIPTION
    scope: local
    type: text
    value: Logs messages in the test
  - description: ''
    name: STEP_EXPECTED
    scope: local
    type: text
    value: All messages loggued in test
  - description: ''
    name: TEST_PURPOSE
    scope: local
    type: text
    value: Log data
testunit: |2-

  def description(self):
      # testcase description
      self.setPurpose(purpose=input('TEST_PURPOSE'))
      self.setRequirement(requirement=description('requirement'))

      # steps description
      self.step1 = self.addStep(expected=input('STEP_EXPECTED'),
                                description=input('STEP_DESCRIPTION'),
                                summary=input('STEP_DESCRIPTION'),
                                enabled=True)
  def prepare(self):
      pass
      
  def definition(self):
      # starting initial step
      if self.step1.isEnabled():
          self.step1.start()

          i = 0
          block = 3
          for log_msg in input('MESSAGES').splitlines():
              if not (i % block):
                  Trace(self).warning(txt="%s" % log_msg[1:].lstrip(), bold=True, italic=False, multiline=False, raw=False)

              if (i % block) == 1:
                  if not len(log_msg): self.abort("bad data line format provided")

                  logs = re.findall("\[!FROM:CACHE:\w+\:\]|\[!FROM:INPUT:\w+\:\]|\[!FROM:OUTPUT:\w+\:\]", log_msg)
                  if len(logs) != 1: self.abort("bad data format provided, expected: [!FROM:CACHE:<.key.>] or [!FROM:OUTPUT:<.name.>]")

                  key = logs[0].split(":")[2:-1][0]

                  if "FROM:CACHE" in log_msg:
                      Trace(self).info(txt="%s" % Cache().get(name=key), bold=False, italic=False, multiline=False, raw=True)

                  if "FROM:INPUT" in log_msg:
                      Trace(self).info(txt="%s" % input(key), bold=False, italic=False, multiline=False, raw=True)

                  if "FROM:OUTPUT" in log_msg:
                      Trace(self).info(txt="%s" % output(key), bold=False, italic=False, multiline=False, raw=True)

              i += 1

          self.step1.setPassed(actual="success")
          
  def cleanup(self, aborted):
      if aborted: self.step1.setFailed(actual="%s" % aborted)
