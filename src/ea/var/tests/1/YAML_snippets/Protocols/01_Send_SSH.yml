properties:
  descriptions:
    author: admin
    requirement: REQ_01
    summary: Just a basic sample.
  parameters:
  - description: ''
    name: ADP_NAME
    scope: local
    type: str
    value: SSH_ADP
  - description: ''
    name: ADP_SHARED
    scope: local
    type: bool
    value: 'False'
  - description: ''
    name: ALREADY_SHARED
    scope: local
    type: bool
    value: 'False'
  - description: ''
    name: COMMANDS
    scope: local
    type: text
    value: |
        # send a ping
        ping -c 3 [!CACHE:SVR:DEST_HOST:]
        .*3 packets transmitted, 3 received, 0% packet loss.*mdev = [!CAPTURE:STATS:] ms.*
        
        # clear the screen
        clear
        .*root@.*
  - description: ''
    name: DEBUG
    scope: local
    type: bool
    value: 'False'
  - description: ''
    name: SERVERS
    scope: local
    type: global
    value: 1:Common:SAMPLE_NODE:SSH_ADMIN
  - description: ''
    name: STEP_EXPECTED
    scope: local
    type: text
    value: SSH command executed
  - description: ''
    name: STEP_SUMMARY
    scope: local
    type: text
    value: Execute SSH commands
  - description: ''
    name: TEST_PURPOSE
    scope: local
    type: text
    value: Send ssh commands
  - description: ''
    name: TIMEOUT
    scope: local
    type: float
    value: '20.0'
  - description: ''
    name: TIMEOUT_CONNECT
    scope: local
    type: float
    value: '10.0'
  - description: ''
    name: VERBOSE
    scope: local
    type: bool
    value: 'True'
testsuite: |2-

  class SEND_SSH_01(TestCase):
      def description(self, svr):
          # testcase description
          self.setPurpose(purpose=input('TEST_PURPOSE'))
          self.setRequirement(requirement=description('requirement'))

          # steps description
          self.step1 = self.addStep(expected="Connected to the remote host with success",
                                    description="Send ssh commands" ,
                                    summary="Connect to the remote machine with ssh protocol",
                                    enabled=True)
                                    
      def prepare(self, svr):
          self.ADP_SYS = None
          if self.step1.isEnabled():
              self.step1.start()

              # adapters and libraries definitions
              if input('ALREADY_SHARED'):
                  self.ADP_SYS = self.findAdapter( input('ADP_NAME') )
                  if self.ADP_SYS is None:
                      self.step1.setFailed(actual="%s adapter not available" % input('ADP_NAME'))
                      self.abort("%s adapter not available" % input('ADP_NAME'))
              else:

                  if "SSH_DEST_HOST" not in svr: self.abort( "SSH_DEST_HOST key expected on provided server. more details\n%s" % svr  )
                  if "SSH_DEST_PORT" not in svr: self.abort( "SSH_DEST_PORT expected on provided server. more details\n%s" % svr )
                  if "SSH_DEST_LOGIN" not in svr: self.abort( "SSH_DEST_LOGIN expected on provided server. more details\n%s" % svr )
                  if "SSH_DEST_PWD" not in svr: self.abort( "SSH_DEST_PWD expected on provided server. more details\n%s" % svr )
                  if "SSH_PRIVATE_KEY" not in svr: self.abort( "SSH_PRIVATE_KEY expected on provided server. more details\n%s" % svr )
                  if "SSH_PRIVATE_KEY_PATH" not in svr: self.abort( "SSH_PRIVATE_KEY_PATH expected on provided server. more details\n%s" % svr )
                  if "SSH_AGENT" not in svr: self.abort( "SSH_AGENT expected on provided server. more details\n%s" % svr )
                  if "SSH_AGENT_SUPPORT" not in svr: self.abort( "SSH_AGENT_SUPPORT expected on provided server. more details\n%s" % svr )

                  self.ADP_SYS = SutAdapters.CLI.SshTerminal(parent=self,
                                                             destIp=svr["SSH_DEST_HOST"],
                                                             destPort=int(svr["SSH_DEST_PORT"]),
                                                             login=svr["SSH_DEST_LOGIN"],
                                                             password=svr["SSH_DEST_PWD"],
                                                             agent=svr['SSH_AGENT'],
                                                             agentSupport=svr['SSH_AGENT_SUPPORT'],
                                                             debug=input('DEBUG'),
                                                             shared=input('ADP_SHARED'),
                                                             name=input('ADP_NAME'),
                                                             verbose=input('VERBOSE'), 
                                                             privateKey=svr['SSH_PRIVATE_KEY'],
                                                             privateKeyPath=svr['SSH_PRIVATE_KEY_PATH'])

      def definition(self, svr):

          if not input('ALREADY_SHARED'):
              if not self.ADP_SYS.doSession(timeout=input('TIMEOUT_CONNECT')):
                  self.step1.setFailed(actual="unable to connect")
                  self.abort("unable to connect")
          self.step1.setPassed(actual="connected the remote host")

          i = 0
          block = 4
          stepN = None
          for sys_cmd in input('COMMANDS').splitlines():
              if not (i % block):
                  searchScreen = False
                  stepN = self.addStep(expected="command executed with success", description=sys_cmd[1:], summary=sys_cmd[1:], enabled=True, thumbnail=None)

              if (i % block) == 1:
                  if stepN is None: continue
                  stepN.start()
                  self.ADP_SYS.doText(text=sys_cmd)

              if (i % block) == 2 and len(sys_cmd):
                  if stepN is None: continue
                  searchScreen = False
                  screen =  self.ADP_SYS.hasReceivedScreen(timeout=input('TIMEOUT'), text=TestOperators.RegEx(needle=sys_cmd))
                  for line in screen.get("TERM", "data").splitlines():
                      self.info(line)
                  if screen is None:
                      stepN.setFailed("unable to find %s in screen" % sys_cmd)
                      self.abort("unable to find %s in screen" % sys_cmd)
                  else:
                      Cache().capture(data=screen.get("TERM", "data"), regexp=sys_cmd)
                      stepN.setPassed("%s found in scren" % sys_cmd)

              if (i % block) == 2 and not len(sys_cmd):
                  if not searchScreen:
                      if stepN is None: continue
                      stepN.setPassed("command executed without return")
                  stepN = None
                  i += 1
              i += 1

      def cleanup(self, aborted, svr):
          if aborted:
              Trace(self).error(txt="%s" % aborted)
          if not input('ALREADY_SHARED'):
              if self.ADP_SYS is not None:
                  self.ADP_SYS.doText(text="exit")
                  self.ADP_SYS.doClose(timeout=input('TIMEOUT_CONNECT'))

                  
  servers = input('SERVERS')
  if servers is None: AbortTestSuite("no server provided")

  if servers is None: AbortTestSuite(reason="no server provided")
  if not isinstance(servers, list): servers = [ input('SERVERS') ]

  for svr in servers:
      _hostname = None
      if "HOSTNAME" in svr:
          _hostname = svr["HOSTNAME"]
      _instance = None
      if "INSTANCE_NAME" in svr:
          _instance = svr["INSTANCE_NAME"]
      _suffix = _hostname
      if _instance is not None:
          _suffix = "%s_%s" % (_hostname, _instance)
      SEND_SSH_01(suffix=_suffix).execute(svr=svr)
